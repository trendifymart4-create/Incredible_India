// Real-time Notification Context for managing global notification state
import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport { useAuth } from './AuthContext';\nimport { notificationService } from '../services/notificationService';\nimport { Notification, NotificationEvent } from '../types/notifications';\n\ninterface NotificationContextType {\n  notifications: Notification[];\n  unreadCount: number;\n  isLoading: boolean;\n  error: string | null;\n  markAsRead: (notificationId: string) => Promise<void>;\n  markAllAsRead: () => Promise<void>;\n  dismissNotification: (notificationId: string) => Promise<void>;\n  requestNotificationPermission: () => Promise<boolean>;\n  registerForPushNotifications: () => Promise<void>;\n  isNotificationSupported: boolean;\n  notificationPermission: NotificationPermission;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\ninterface NotificationProviderProps {\n  children: ReactNode;\n}\n\nexport const NotificationProvider: React.FC<NotificationProviderProps> = ({ children }) => {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [notificationPermission, setNotificationPermission] = useState<NotificationPermission>(\n    'default'\n  );\n  \n  const { currentUser } = useAuth();\n  const isNotificationSupported = 'Notification' in window && 'serviceWorker' in navigator;\n\n  // Initialize notification permission state\n  useEffect(() => {\n    if (isNotificationSupported) {\n      setNotificationPermission(Notification.permission);\n    }\n  }, [isNotificationSupported]);\n\n  // Subscribe to notifications when user is logged in\n  useEffect(() => {\n    if (!currentUser) {\n      setNotifications([]);\n      setUnreadCount(0);\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    const unsubscribe = notificationService.subscribeToUserNotifications(\n      currentUser.uid,\n      (newNotifications) => {\n        setNotifications(newNotifications);\n        const unread = newNotifications.filter(n => !n.isRead).length;\n        setUnreadCount(unread);\n        setIsLoading(false);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [currentUser]);\n\n  // Listen for notification events\n  useEffect(() => {\n    const handleNotificationEvent = (event: NotificationEvent) => {\n      switch (event.type) {\n        case 'NOTIFICATION_RECEIVED':\n          // Show browser notification if permission granted\n          if (notificationPermission === 'granted' && event.payload) {\n            showBrowserNotification(event.payload);\n          }\n          break;\n        case 'NOTIFICATION_READ':\n          // Update local state optimistically\n          setNotifications(prev => \n            prev.map(n => \n              n.id === event.payload.notificationId \n                ? { ...n, isRead: true } \n                : n\n            )\n          );\n          setUnreadCount(prev => Math.max(0, prev - 1));\n          break;\n        case 'NOTIFICATION_DISMISSED':\n          // Remove from local state\n          setNotifications(prev => \n            prev.filter(n => n.id !== event.payload.notificationId)\n          );\n          break;\n      }\n    };\n\n    const unsubscribe = notificationService.addEventListener(handleNotificationEvent);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [notificationPermission]);\n\n  // Show browser notification\n  const showBrowserNotification = (notification: Notification) => {\n    if (!isNotificationSupported || notificationPermission !== 'granted') {\n      return;\n    }\n\n    const options: NotificationOptions = {\n      body: notification.message,\n      icon: notification.metadata?.imageUrl || '/icon-192x192.png',\n      badge: '/badge-72x72.png',\n      tag: notification.id,\n      requireInteraction: notification.priority === 'urgent' || notification.priority === 'high',\n      silent: notification.priority === 'low',\n      data: {\n        notificationId: notification.id,\n        actionUrl: notification.metadata?.actionUrl\n      }\n    };\n\n    // Add action buttons for interactive notifications\n    if (notification.metadata?.actionUrl) {\n      options.actions = [\n        {\n          action: 'open',\n          title: getActionButtonText(notification.type),\n          icon: '/icon-action.png'\n        },\n        {\n          action: 'dismiss',\n          title: 'Dismiss',\n          icon: '/icon-close.png'\n        }\n      ];\n    }\n\n    try {\n      const browserNotification = new Notification(notification.title, options);\n      \n      // Handle notification click\n      browserNotification.onclick = () => {\n        if (notification.metadata?.actionUrl) {\n          window.open(notification.metadata.actionUrl, '_blank');\n        }\n        browserNotification.close();\n      };\n\n      // Auto close after some time for low priority notifications\n      if (notification.priority === 'low' || notification.priority === 'medium') {\n        setTimeout(() => {\n          browserNotification.close();\n        }, 5000);\n      }\n    } catch (error) {\n      console.error('Error showing browser notification:', error);\n    }\n  };\n\n  // Get action button text based on notification type\n  const getActionButtonText = (type: string): string => {\n    switch (type) {\n      case 'destination':\n        return 'View Destination';\n      case 'vr_tour':\n        return 'Start VR Tour';\n      case 'announcement':\n        return 'Learn More';\n      default:\n        return 'Open';\n    }\n  };\n\n  // Request notification permission\n  const requestNotificationPermission = async (): Promise<boolean> => {\n    if (!isNotificationSupported) {\n      console.warn('Notifications not supported');\n      return false;\n    }\n\n    try {\n      const permission = await Notification.requestPermission();\n      setNotificationPermission(permission);\n      return permission === 'granted';\n    } catch (error) {\n      console.error('Error requesting notification permission:', error);\n      return false;\n    }\n  };\n\n  // Register for push notifications\n  const registerForPushNotifications = async (): Promise<void> => {\n    if (!currentUser) {\n      throw new Error('User must be logged in to register for push notifications');\n    }\n\n    if (!isNotificationSupported) {\n      throw new Error('Push notifications not supported');\n    }\n\n    try {\n      // Request permission first if not granted\n      if (notificationPermission !== 'granted') {\n        const granted = await requestNotificationPermission();\n        if (!granted) {\n          throw new Error('Notification permission denied');\n        }\n      }\n\n      // Register device token with Firebase\n      const token = await notificationService.registerDeviceToken(currentUser.uid, 'web');\n      \n      if (token) {\n        console.log('Successfully registered for push notifications');\n        \n        // Listen for foreground messages\n        notificationService.onForegroundMessage((payload) => {\n          console.log('Received foreground message:', payload);\n          \n          // Show notification even when app is in foreground\n          if (payload.notification) {\n            const notification: Notification = {\n              id: Date.now().toString(),\n              title: payload.notification.title || 'New Notification',\n              message: payload.notification.body || '',\n              type: payload.data?.type || 'announcement',\n              category: payload.data?.category || 'update',\n              priority: payload.data?.priority || 'medium',\n              targetAudience: 'all',\n              adminId: payload.data?.adminId || '',\n              createdAt: { seconds: Date.now() / 1000, nanoseconds: 0 } as any,\n              metadata: {\n                actionUrl: payload.data?.actionUrl,\n                imageUrl: payload.notification.image\n              }\n            } as Notification;\n            \n            showBrowserNotification(notification);\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error registering for push notifications:', error);\n      throw error;\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async (notificationId: string): Promise<void> => {\n    if (!currentUser) return;\n    \n    try {\n      await notificationService.markAsRead(notificationId, currentUser.uid);\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n      setError('Failed to mark notification as read');\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async (): Promise<void> => {\n    if (!currentUser) return;\n    \n    try {\n      await notificationService.markAllAsRead(currentUser.uid);\n    } catch (error) {\n      console.error('Error marking all notifications as read:', error);\n      setError('Failed to mark all notifications as read');\n    }\n  };\n\n  // Dismiss notification\n  const dismissNotification = async (notificationId: string): Promise<void> => {\n    if (!currentUser) return;\n    \n    try {\n      await notificationService.dismissNotification(notificationId, currentUser.uid);\n    } catch (error) {\n      console.error('Error dismissing notification:', error);\n      setError('Failed to dismiss notification');\n    }\n  };\n\n  const value: NotificationContextType = {\n    notifications,\n    unreadCount,\n    isLoading,\n    error,\n    markAsRead,\n    markAllAsRead,\n    dismissNotification,\n    requestNotificationPermission,\n    registerForPushNotifications,\n    isNotificationSupported,\n    notificationPermission\n  };\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport const useNotifications = (): NotificationContextType => {\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n\nexport default NotificationContext;